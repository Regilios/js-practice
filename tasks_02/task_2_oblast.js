function foo(str, a) {
	eval( str ); // обман!
	console.log( a, b );
}

var b = 2;

foo( "var b = 3;", 1 ); // 1, 3
/**
 * Функция eval(..) в JavaScript берет строку как аргумент и интерпретирует содержимое строки как если бы это был код, написанный в этой точке программы. 
 * Другими словами, вы можете программно генерировать код внутри вашего собственного кода и запускать сгенерированный код как если бы он был там во время написания кода.
 * При вычислении eval(..) в таком свете, должно быть ясно как eval(..) позволяет модифицировать окружение лексической области видимости, обманывая и притворяясь, что этот код был тут всё время.
 * Строка "var b = 3;" интерпретируется в точке вызова eval(..), как будто этот код был тут всегда. Поскольку этот код объявляет новую переменную b, он изменяет существующую лексическую область foo(..). 
 * 
 * Фактически, как было указано выше, этот код на самом деле создает переменную b внутри foo(..), которая затеняет b, которая была объявлена во внешней (глобальной) области видимости.
 * Когда происходит вызов console.log(..), он находит и a, и b в области видимости foo(..), но никогда не найдет внешнюю b. По этой причине, мы напечатаем "1, 3" вместо "1, 2" как это было бы в обычном случае.
 * Примечание: В этом примере для простоты строка "кода", которую мы передали, была фиксированным литералом.
 * Но она легко может быть создана программно соединением символов вместе на основе логики вашей программы. eval(..) обычно используется для динамически созданного кода, поскольку динамическое
 * вычисление по существу статического кода из строкового литерала не дает никакого реального преимущества перед простым написанием этого кода напрямую.
 * 
 * По умолчанию, если строка кода, которую выполняет eval(..), содержит одно или более объявлений (переменных или функций), тогда это действие меняет существующую лексическую область видимости, в которой располагается eval(..). 
 * Технически, eval(..) может быть вызвана "неявно", путем различных трюков (вне нашего обсуждения здесь), которые приводят к тому, что она вместо этого запускается в контексте глобальной области видимости, таким образом меняя ее. 
 * Но в любом случае, eval(..) может во время исполнения менять лексическую область видимости, определенную на момент написания кода.
 * 
 * Примечание: Когда eval(..) используется в программе, работающей в строгом режиме, она работает со своей собственной лексической областью видимости, что означает, что объявления, сделанные внутри eval(), не поменяют окружающую область видимости.
 * 
 * function foo(str) {
    "use strict";
    eval( str );
    console.log( a ); // ReferenceError: a is not defined
    }

    foo( "var a = 2" );
 */