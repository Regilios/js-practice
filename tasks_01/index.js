[] + {} // → "[object Object]"
/**
 * Оператор + работает с двумя операндами.
Если хотя бы один из них не число , JS пытается привести оба к примитивам (обычно к строке или числу).
Для объектов (включая массивы) вызывается метод Symbol.toPrimitive, а если его нет — то valueOf() и toString().

[] — это массив, он преобразуется в примитив через toString().
[].toString() → "" (пустая строка)
{} — это объект, его toString() → "[object Object]"
Теперь выражение становится: "" + "[object Object]" → "[object Object]"

 */

{} + [] === 0 
/**
 * Причина в том, что браузер интерпретирует {} как пустой блок кода , а не как объект!
 * JS считает, что {} — это просто пустой блок, как { ... } в if (...) { ... }.
 * оастётся +[] Унарный + перед массивом пытается привести его к числу +[] → 0
 * 
 */

({}) + [] // → "[object Object]"
/**
 *  {} воспринимается как пустой блок , а не как объект за счёт ()
 */

{} + {} // → NaN
/**
 * В консоли: {} + {} // → NaN
Первое {} интерпретируется как пустой блок
Выражение становится: +{}
Теперь JS пытается привести объект {} к числу:
{} → через ToNumber → NaN
 */

({} + {}) // → "[object Object][object Object]"

/*********************************** */
console.log(
    ((x,y) => (
        ((proc2) =>(
            ((proc1)=>proc1(5,30))((x,y) => [x, proc2(), y])
        ))(()=>x + y)
    ))(10, 15)
);
/* 
Есть несколько вложенных стрелочных функций
Используются IIFE (Immediately Invoked Function Expressions) — функции, которые создаются и вызываются сразу
Происходит замыкание , передача функции как аргумента , многоуровневое возвращение результата

((x, y) => ...)(10, 15) принимает x = 10, y = 15

Анонимная стрелочная функция, принимающая два параметра x и y, и сразу вызываемая с аргументами 10 и 15.
Типы:
x → number (10)
y → number (15)
(x, y) => ... → function
((x, y) => ...)(10, 15) → результат выполнения функции


((proc2) => (
    ((proc1) => proc1(5,30))((x,y) => [x, proc2(), y])
))(() => x + y)

Внешняя функция принимает x = 10, y = 15
Теперь она создает и вызывает ещё одну IIFE:
Создаётся и сразу вызывается функция:
(proc2) => (...),
Аргумент proc2 будет передан как () => x + y
x и y здесь взяты из внешней области видимости, то есть из x = 10, y = 15. То есть proc2() вернёт 25. 

((proc1) => proc1(5, 30))((x, y) => [x, proc2(), y])

Снова IIFE:

Создаётся функция (proc1) => proc1(5, 30)
Вызывается с аргументом: (x, y) => [x, proc2(), y]
То есть:

proc1 = (x, y) => [x, proc2(), y]
Затем вызывается как proc1(5, 30)

(x, y) => [x, proc2(), y]
Принимает x = 5, y = 30
Вызывает proc2() → что возвращает x + y → 10 + 15 = 25
Возвращает массив: [x, proc2(), y] → [5, 25, 30]
*/


/*********************************** */
var x = function bar(){
	var a = 0;
	return a;
};

var b = x();
b;
/**
 * bar — это имя функции , а не свойство.
 * В JavaScript функции — это объекты , и у них могут быть свои свойства, но они должны быть установлены явно.
 * Переменная a объявлена внутри функции , значит она локальная и недоступна извне.
 * Единственный способ получить значение a — это вернуть его из функции и сохранить где-то.
 */

/*********************************** */
function makeAdder(x) {
  function add(y) {
    return y + x;
  }
  return add;
}

var plusOne = makeAdder(1);
plusOne(3); // 4

/**
 *  Это фабричная функция: она создаёт и возвращает другую функцию.
    Она принимает один параметр: x
    Вызывается makeAdder(1)
    Внутри неё создаётся новая функция add(y), которая "запоминает" значение x = 1
    Эта функция возвращается и сохраняется в переменной plusOne
    Теперь plusOne — это функция add(y), у которой есть доступ к переменной x = 1, даже после завершения makeAdder.

    plusOne(3);
    Теперь ты вызываешь функцию add(y), которая была создана ранее. При этом:
        y = 3 (аргумент, который ты передал)
        x = 1 (сохранённое значение из замыкания)
    
|*******************| 
    return add; я возвращаю ссылку на функцию которая будет привязана к plusOne 
    

 */