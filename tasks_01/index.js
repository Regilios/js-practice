const buffer = new ArrayBuffer(8); // 8 байт
const view = new Int32Array(buffer);

view[0] = 42;
view[1] = -100;

const byteView = new Int8Array(buffer);
console.log(byteView);
// Int8Array(8) [42, 0, 0, 0, -100, -1, -1, -1, buffer: ArrayBuffer(8), byteLength: 8, byteOffset: 0, length: 8, Symbol(Symbol.toStringTag): 'Int8Array']

/**
 * в JavaScript типизированные значения, а не типизированные переменные. Доступны следующие встроенные типы:

    string (строка)
    number (число)
    boolean (логическое значение)
    null и undefined (пустое значение)
    object (объект)
    symbol (символ, новое в ES6)

    Хотя в JavaScript нет отдельного типа int или short , но есть типизированные массивы (TypedArray) ,
    которые позволяют работать с бинарными данными как с массивами целых чисел фиксированной длины.

    Они используются вместе с ArrayBuffer и DataView.
    Int8Array            -128 до 127
    Uint8Array            0 до 255
    Uint8ClampedArray     0 до 255 (без переполнения)
    Int16Array           -32768 до 32767  
    Uint16Array           0 до 65535
    Int32Array           -2147483648 до 2147483647
    Uint32Array           0 до 4294967295
    Float32Array         ±3.4e38
    Float64Array         ±1.8e308
    BigInt64Array        -2^63 до 2^63−1
    BigUint64Array       0 до 2^64−1

    ArrayBuffer - это сырой блок памяти фиксированного размера (в байтах), где хранятся данные в виде байтов.
   
    ! Все TypedArray, созданные на основе одного и того же ArrayBuffer, ссылаются на один и тот же участок памяти !
    
    когда мы вычлесляем const view = new Int32Array(buffer); мы преобразуем блок памяти из ArrayBuffer в нужное числовое представление и после помещаем в него 42 -100
    view и byteView — это два разных способа интерпретировать одни и те же байты

    const byteView = new Int8Array(buffer);

*/


const INTERVAL = 10; 
/** 
 * 
 * INTERVAL выражение вычеслить идентификатор INTERVAL в лекическом окруженеии в RunTime есть ли такие же области
 * в памяти которым было присвоено имя INTERVAL 
 * (это происходит до выполнения кода, если есть хоть 1 обявление let const интерпритатор обязан проверить весь код на повтороное объявление) 
 * если нет то Environment Record присвоит области памяти это имя
 * после Lexical Environment свяжет эту ячейку с внешним оркужением 
 * 
 * через механизм назначения const INTERVAL идентификатору назначаются свойства связывания -
 * неинициализрована, немутабельна, удаляемость, определить блочную область видиомсти (Declarative Environment Record), запрет повтороного объявления
 * автоматическое поднятие (без инициализации, остаётся в TDZ)
 * 
 * выражение 10 - вычислисть числовой литерал и получить его значение 10
 * выражение = связывание (асаймент), связать 1 и 2 выражения между собой 
 * 
 * INTERVAL сам по себе не имеет типа он содержит ссыылку на область памяти которая внутри себя имеет стркутуру которая 
 * её определяет и в последствии через неё происходит взаимодействие когда требуется уже использовать её в каком то выражении
 * в данном случае числовой тип. Эта же структура указывает как происходит преобразование типов, как разные типы данныех взаимодействуют друг с другом
 * 
 * Числа — это примитивные типы. Они передаются по значению, а не по ссылке.
 * 
 * например когда складывается число и строка 0 + "1" Если хотя бы один из них не число , JS пытается привести оба к примитивам (обычно к строке или числу).
 * "11" + 1 → "111"  Сложение - один из операндов — строка → конкатенация
 * +"11" + 1  →  12    Унарный плюс / минус  - строка явно приводится к числу 
 * Number("11") + 1 → 12  Явное преобразование
 * "11" - 1 → 10   Неявное преобразование → Вычетание всегда работает с числами 
 * "11" * 2 → 22   Умножение и деление работает только с числами
 */
/*********************************** */

[] + {} // → "[object Object]"
/**
 * Оператор + работает с двумя операндами.
Если хотя бы один из них не число , JS пытается привести оба к примитивам (обычно к строке или числу).
Для объектов (включая массивы) вызывается метод Symbol.toPrimitive, а если его нет — то valueOf() и toString().

[] — это массив, он преобразуется в примитив через toString().
[].toString() → "" (пустая строка)
{} — это объект, его toString() → "[object Object]"
Теперь выражение становится: "" + "[object Object]" → "[object Object]"

 */

{} + [] === 0 
/**
 * Причина в том, что браузер интерпретирует {} как пустой блок кода , а не как объект!
 * JS считает, что {} — это просто пустой блок, как { ... } в if (...) { ... }.
 * оастётся +[] Унарный + перед массивом пытается привести его к числу +[] → 0
 * 
 */

({}) + [] // → "[object Object]"
/**
 *  {} воспринимается как пустой блок , а не как объект за счёт ()
 */

{} + {} // → NaN
/**
 * В консоли: {} + {} // → NaN
Первое {} интерпретируется как пустой блок
Выражение становится: +{}
Теперь JS пытается привести объект {} к числу:
{} → через ToNumber → NaN
 */

({} + {}) // → "[object Object][object Object]"

/*********************************** */
console.log(
    ((x,y) => (
        ((proc2) =>(
            ((proc1)=>proc1(5,30))((x,y) => [x, proc2(), y])
        ))(()=>x + y)
    ))(10, 15)
);
/* 
Есть несколько вложенных стрелочных функций
Используются IIFE (Immediately Invoked Function Expressions) — функции, которые создаются и вызываются сразу
Происходит замыкание , передача функции как аргумента , многоуровневое возвращение результата

((x, y) => ...)(10, 15) принимает x = 10, y = 15

Анонимная стрелочная функция, принимающая два параметра x и y, и сразу вызываемая с аргументами 10 и 15.
Типы:
x → number (10)
y → number (15)
(x, y) => ... → function
((x, y) => ...)(10, 15) → результат выполнения функции


((proc2) => (
    ((proc1) => proc1(5,30))((x,y) => [x, proc2(), y])
))(() => x + y)

Внешняя функция принимает x = 10, y = 15
Теперь она создает и вызывает ещё одну IIFE:
Создаётся и сразу вызывается функция:
(proc2) => (...),
Аргумент proc2 будет передан как () => x + y
x и y здесь взяты из внешней области видимости, то есть из x = 10, y = 15. То есть proc2() вернёт 25. 

((proc1) => proc1(5, 30))((x, y) => [x, proc2(), y])

Снова IIFE:

Создаётся функция (proc1) => proc1(5, 30)
Вызывается с аргументом: (x, y) => [x, proc2(), y]
То есть:

proc1 = (x, y) => [x, proc2(), y]
Затем вызывается как proc1(5, 30)

(x, y) => [x, proc2(), y]
Принимает x = 5, y = 30
Вызывает proc2() → что возвращает x + y → 10 + 15 = 25
Возвращает массив: [x, proc2(), y] → [5, 25, 30]
*/


/*********************************** */
var x = function bar(){
	var a = 0;
	return a;
};

var b = x();
b;
/**
 * bar — это имя функции , а не свойство.
 * В JavaScript функции — это объекты , и у них могут быть свои свойства, но они должны быть установлены явно.
 * Переменная a объявлена внутри функции , значит она локальная и недоступна извне.
 * Единственный способ получить значение a — это вернуть его из функции и сохранить где-то.
 */

/*********************************** */
function makeAdder(x) {
  function add(y) {
    return y + x;
  }
  return add;
}

var plusOne = makeAdder(1);
plusOne(3); // 4

/**
 *  Это фабричная функция: она создаёт и возвращает другую функцию.
    Она принимает один параметр: x
    Вызывается makeAdder(1)
    Внутри неё создаётся новая функция add(y), которая "запоминает" значение x = 1
    Эта функция возвращается и сохраняется в переменной plusOne
    Теперь plusOne — это функция add(y), у которой есть доступ к переменной x = 1, даже после завершения makeAdder.

    plusOne(3);
    Теперь ты вызываешь функцию add(y), которая была создана ранее. При этом:
        y = 3 (аргумент, который ты передал)
        x = 1 (сохранённое значение из замыкания)
    
|*******************| 
    return add; я возвращаю ссылку на функцию которая будет привязана к plusOne 
 */

